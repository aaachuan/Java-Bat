source code:
```
package org.fenixsoft.clazz;
public class TestClass {
	private int m;
	public int inc() {
		return m + 1;
	}
}
```
class byte code:
```
CAFEBABE0000003400130A0004000F09000300100700110700120100016D010001490100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C65010003696E6301000328294901000A536F7572636546696C6501000E54657374436C6173732E6A6176610C000700080C0005000601001D6F72672F66656E6978736F66742F636C617A7A2F54657374436C6173730100106A6176612F6C616E672F4F626A6563740021000300040000000100020005000600000002000100070008000100090000001D00010001000000052AB70001B100000001000A000000060001000000020001000B000C000100090000001F00020001000000072AB400020460AC00000001000A000000060001000000050001000D00000002000E
```
### 魔数(Magic Number)
4个字节
```
CAFEBABE
```
### Class文件版本
Minor Version + Major Version
```
00000034
```
Java版本号从45开始，34H即52。我的是JDK版本是1.8.0_201。
### 常量池
常量池的数量是不固定的，入口是两个字节的无符号数，即上面的`0013`，即十进制的19，代表常量池有18个常量，比较特别的是计数是从1开始的，索引值置为0代表不引用任何一个常量池项目。常量池项目类型繁多，每种类型都有自己的结构。

首先看下一字节为`0A`，查书上的表tag为10是`CONSTANT_Methodref_info`，表示类中方法的符号引用，发现这个部分总共占5个字节。即
```
0A 0004 000F
```
`0A`即上面讲的标志位tag，`0004`和`000F`两个索引值分别对应**指向声明方法的类描述符CONSTANT_Class_info的索引项**和**指向名称及类型描述符CONSTANT_NameAndType**的索引项。这个和书上的编译结果略有出入。
***
仔细对比了下，跟书上差的好多。初步可以确定下下面的部分：
```
6F72672F66656E6978736F66742F636C617A7A2F54657374436C617373
```
即为`org/fenixsoft/clazz/TestClass`；
及前面的`01001D`为CONSTANT_Utf8_info，即UTF-8编码的字符串。`01`是tag标志位，`001D`即length，长29个字节，就是上面的那一串：
```
6F72672F66656E6978736F66742F636C617A7A2F54657374436C617373
```
刚好29个字节。

但是中间夹塞的一大串书上没讲到，初步猜想可能是版本变化增加的特性。书上还有个细节没大明白，就是CONSTANT_Class_info的name_index值为0x0002也即指向了常量池中的第二项常量？书上常量池的项目类型比较特殊的是表里面没有对应2的标志位，还有13,14,17。

